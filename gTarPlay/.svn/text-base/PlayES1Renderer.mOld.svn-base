//
//  PlayES1Renderer.m
//  gTarPlay
//
//  Created by Marty Greenia on 3/10/11.
//  Copyright 2011 Msft. All rights reserved.
//

#import "PlayES1Renderer.h"

@implementation PlayES1Renderer

- (id)initWithSong:(SongModel*)song
{
	if ( self = [super init] )
	{
		
		m_songModel = song;
		
	}
	
	return self;

}

- (void)dealloc
{
	[self releaseModelTextures];
	[super dealloc];
}

- (BOOL)resizeFromLayer:(CAEAGLLayer *)layer
{

	// this sets the backing height/width, among other things
	BOOL result = [super resizeFromLayer:layer];

	// clear up any preexisting textures
	[self releaseModelTextures];
	
	// Note that we need to have already resized the layer once
	// before we can create the textures, because prior to the first
	// resizing our layersize is 0x0.
	[self createModelTextures];
	
	return result;
}

- (void)createModelTextures
{

	[self createNumberModels];
	[self createStringModels];
	[self createNoteModels:m_songModel->m_noteArray];
	[self createLineModels:m_songModel->m_measureArray];
//	[self createCountdownModels];

}

- (void)releaseModelTextures
{
	
//	[m_countdownModels release];
	[m_seekLineModel release];
	[m_lineModels release];
	[m_noteModels release];
	[m_stringModels release];	
	[m_numberModels release];
	
	[m_noteAnimations release];

}

#pragma mark -
#pragma mark Model and texture creation

- (void)createStringModels
{
	
	m_stringModels = [[NSMutableArray alloc] init];
	
	CGPoint center;
	center.x = GL_SCREEN_WIDTH / 2.0;
	
	CGSize size;
	size.width = GL_SCREEN_WIDTH;
	
	for ( unsigned int i = 0; i < GTAR_GUITAR_STRING_COUNT; i++ )
	{

		// strings number and size are inversely proportional -- get slightly bigger
		size.height = GL_STRING_HEIGHT + (GTAR_GUITAR_STRING_COUNT - 1 - i) * GL_STRING_HEIGHT_INCREMENT;
		center.y = [self convertStringToCoordSpace:i];
		
		StringModel * stringModel = [[StringModel alloc] initWithCenter:center andSize:size andColor:( g_stringColors[i] )];

		[m_stringModels addObject:stringModel];
		
		[stringModel release];
		
	}

}

- (void)createNoteModels:(NoteArray*)noteArray
{
	
	// createNumberModels has to run first
	// so the overlay numbers can be used.
	CNote * notes = noteArray->m_notes;

	m_noteModels = [[NSMutableArray alloc] init];
	m_noteAnimations = [[NSMutableArray alloc] init];
	
	for ( unsigned int i = 0; i < noteArray->m_noteCount; i++ )
	{
		GuitarString str = notes[i].m_string;
		GuitarFret fret = notes[i].m_fret;
		
		CGPoint center;
		center.x = [self convertBeatToCoordSpace:notes[i].m_absoluteBeatStart];
		center.y = [self convertStringToCoordSpace:str];
		
		CGSize size;
		size.height = GL_NOTE_HEIGHT;
		size.width = GL_NOTE_HEIGHT;

		// number texture overlay
		NumberModel * overlay = [m_numberModels objectAtIndex:fret];
		
		NoteModel * noteModel = [[NoteModel alloc] initWithCenter:center
														  andSize:size
														 andColor:g_stringColors[str]
													   andOverlay:overlay];

		[m_noteModels addObject:noteModel];

#if 0
		// Animation stuff
		NoteModel * noteModel2 = [[NoteModel alloc] initWithCenter:center
														   andSize:size
														  andColor:g_grayColor
														andOverlay:overlay];
		
		
		NoteModel * noteModel3 = [[NoteModel alloc] initWithCenter:center
														   andSize:size
														  andColor:g_whiteColor
														andOverlay:overlay];
		
		Animation * noteAnimation = [[Animation alloc] initWithFramesPerModel:5];
		
		[noteAnimation addModel:noteModel];
		[noteAnimation addModel:noteModel2];
		[noteAnimation addModel:noteModel3];
		
		//[noteAnimation startAnimation:YES];
		
		[m_noteAnimations addObject:noteAnimation];
		[noteModel2 release];
		[noteModel3 release];
		[noteAnimation release];
		
#else
		
		NoteAnimation * noteAnimation = [[NoteAnimation alloc] initWithCenter:center andSize:size andColor:g_stringColors[str] andOverlay:overlay];
		[m_noteAnimations addObject:noteAnimation];
		[noteAnimation release];

#endif
		
		[noteModel release];
		
	}
	
}

//- (void)createCountdownModels
//{
//
//	m_countdownModels = [[NSMutableArray alloc] init];
//	
//	CGPoint center;
//	center.y = GL_SCREEN_HEIGHT / 2.0;
//	center.x = GL_SCREEN_WIDTH / 2.0;
//	
//	CGSize size;
//	size.width = GL_STRING_HEIGHT * 4;
//	size.height = GL_STRING_HEIGHT * 4;
//	
//	TextModel * textModel = [[TextModel alloc] initWithCenter:center andSize:CGSizeMake(128, 128) andColor:g_whiteColor andText:@"GO!!" andHeight:60];
//
//	// insert the "GO"
//	[m_countdownModels insertObject:textModel atIndex:0];
//	
//	[textModel release];
//	
//	// insert 1-3
//	for ( unsigned int i = 1; i < PLAY_COUNTDOWN_LENGTH; i++ )
//	{
//		
//		NumberModel * numberModel = [[NumberModel alloc] initWithCenter:center andSize:size andColor:g_whiteColor andValue:i];
//		
//		[m_countdownModels insertObject:numberModel atIndex:i];
//
//		[numberModel release];
//		
//	}
//
//	[self countdownOff];
//	
//}

- (void)createLineModels:(MeasureArray*)measureArray
{
	
	CMeasure * measures = measureArray->m_measures;
	
	m_lineModels = [[NSMutableArray alloc] init];
	
	CGSize size;
	size.width = GL_STRING_HEIGHT;
	size.height = GL_SCREEN_HEIGHT;
	
	for ( unsigned int i = 0; i < measureArray->m_measureCount; i++ )
	{
		
		CGPoint center;
		center.y = GL_SCREEN_HEIGHT / 2.0;
		center.x = [self convertBeatToCoordSpace:measures[i].m_startBeat];
		
		LineModel * lineModel = [[LineModel alloc] initWithCenter:center andSize:size andColor:g_measureColors];
		
		[m_lineModels addObject:lineModel];
		
		[lineModel release];
	}
	
	// create the seek line
	CGPoint center;
	center.y = GL_SCREEN_HEIGHT / 2.0;
	center.x = GL_ORTHO_LEFT + GL_SCREEN_SEEK_LINE_OFFSET;
	
	m_seekLineModel = [[LineModel alloc] initWithCenter:center andSize:size andColor:g_whiteColor];
}

- (void)createNumberModels
{
	
	m_numberModels = [[NSMutableArray alloc] init];
	
	CGSize size;
	size.width = GL_NOTE_HEIGHT;
	size.height = GL_NOTE_HEIGHT;
	
	for ( unsigned int i = 0; i < GTAR_GUITAR_FRET_COUNT; i++ )
	{
		
		NumberModel * numberModel = [[NumberModel alloc] initWithCenter:CGPointMake(0, 0) andSize:size andColor:g_whiteColor andValue:i];
		
		[m_numberModels addObject:numberModel];
		
		[numberModel release];
	}
}

#pragma mark -
#pragma mark Helpers

- (GLfloat)convertBeatToCoordSpace:(CGFloat)beat
{
	return beat * (GLfloat)PLAY_PIXELS_PER_BEAT;
}

- (GLfloat)convertStringToCoordSpace:(NSInteger)str
{
	GLfloat effectiveScreenHeight = (GL_SCREEN_HEIGHT) - (GL_SCREEN_TOP_BUFFER + GL_SCREEN_BOTTOM_BUFFER);
	
	GLfloat heightPerString = effectiveScreenHeight / ((GLfloat)GTAR_GUITAR_STRING_COUNT-1);
	
	return GL_ORTHO_BOTTOM + GL_SCREEN_BOTTOM_BUFFER + ( str * heightPerString );
}

#pragma mark -
#pragma mark External access 

- (void)updateCurrentPosition
{
	m_currentPosition = [self convertBeatToCoordSpace:m_songModel->m_currentBeat];
}

- (void)countdownOn:(NSInteger)count
{	
	m_currentCountdown = count;
}

- (void)countdownOff
{
	m_currentCountdown = PLAY_COUNTDOWN_LENGTH;
}

- (void)animateNoteWithIndex:(NSInteger)index
{
	
	Animation * animation = [m_noteAnimations objectAtIndex:index];
	
	[animation startAnimation:NO];
	
}

- (void)resetAnimations
{
	for ( unsigned int index = 0; index < [m_noteAnimations count]; index++)
	{
		Animation * animation = [m_noteAnimations objectAtIndex:index];
		
		[animation resetAnimation];		
	}	
}

#pragma mark -
#pragma mark Render

- (void)render
{
	// update model
	[self updateCurrentPosition];

	// init stuff
	[EAGLContext setCurrentContext:m_context];
    
    glBindFramebufferOES(GL_FRAMEBUFFER_OES, m_defaultFramebuffer);
    glViewport(0, 0, m_backingWidth, m_backingHeight);

	
	// Set up the projection
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrthof( GL_ORTHO_LEFT, GL_ORTHO_RIGHT,
			GL_ORTHO_BOTTOM, GL_ORTHO_TOP,
			  GL_ORTHO_NEAR, GL_ORTHO_FAR );
	
	//
	// Draw the model geometry
	//
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	
    // Set background color
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

	//
	// Textures
	//
	// texturing will need these
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	glEnableClientState(GL_VERTEX_ARRAY);
	glEnableClientState(GL_COLOR_ARRAY);
	glEnable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	
	// Blend function for textures
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	
	// draw strings
	for ( unsigned int index = 0; index < [m_stringModels count]; index++)
	{
		LineModel * stringModel = [m_stringModels objectAtIndex:index];
		
		[stringModel draw];		
	}	

	// draw the seek line
	[m_seekLineModel draw];
	

	// translate to the left
	glTranslatef(GL_ORTHO_LEFT + GL_SCREEN_SEEK_LINE_OFFSET - m_currentPosition, 0.0f, 0.0f);

	// draw lines
	for ( unsigned int index = 0; index < [m_lineModels count]; index++)
	{
		LineModel * lineModel = [m_lineModels objectAtIndex:index];
		
		[lineModel draw];		
	}
	
	// draw notes
	
#if 0
	for ( unsigned int index = 0; index < [m_noteModels count]; index++)
	{
		NoteModel * noteModel = [m_noteModels objectAtIndex:index];
		
		[noteModel draw];		
	}
#else
	for ( unsigned int index = 0; index < [m_noteAnimations count]; index++)
	{
		Animation * animation = [m_noteAnimations objectAtIndex:index];
		
		[animation drawCurrentFrameAndAdvanceFrame];		
	}	
	
#endif
	
	// Back to normal for geometry
//	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
//	glDisable(GL_TEXTURE_2D);
//	glDisable(GL_BLEND);

	//
	//this is dumb, no one likes the countdown
	/*
	glLoadIdentity();
	
	// Draw the countdown timer, if applicable.
	if ( m_currentCountdown < PLAY_COUNTDOWN_LENGTH )
	{
		Model * model = [m_countdownModels objectAtIndex:m_currentCountdown];
		[model draw];
	}
*/
	// finish stuff
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, m_colorRenderbuffer);
    [m_context presentRenderbuffer:GL_RENDERBUFFER_OES];

}

@end
